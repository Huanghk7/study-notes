# Redis学习

## 2022.10.31

### 一、RDB快照

RDB 快照就是记录**某一个瞬间的内存数据，记录的是实际数据**，而 AOF 文件记录的是命令操作的日志，而不是实际的数据。

因此在 Redis 恢复数据时， RDB 恢复数据的效率会比 AOF 高些，因为直接**将 RDB 文件读入内存**就可以，不需要像 AOF 那样还需要**额外执行操作命令的步骤才能恢复数据**。

Redis 提供了两个命令来生成 RDB 文件，分别是 `save` 和 `bgsave`，他们的区别就在于是否在「主线程」里执行：

- 执行了 save 命令，就会在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，所以如果写入 RDB 文件的时间太长，**会阻塞主线程**；
- 执行了 bgsave 命令，会创建一个子进程来生成 RDB 文件，这样可以**避免主线程的阻塞**；

RDB 文件的加载工作是在服务器启动时自动执行的，Redis 并没有提供专门用于加载 RDB 文件的命令。 

 RDB 快照的缺点，在服务器发生故障时，丢失的数据会比 AOF 持久化的方式更多，因为 RDB 快照是全量快照的方式，因此执行的频率不能太频繁，否则会影响 Redis 性能，而 AOF 日志可以以秒级的方式记录操作命令，所以丢失的数据就相对更少。 



### 二、Redis过期删除策略

Redis有四种给key设置过期时间的命令，分别是

1. expire key 100	// 100s后过期
	. pexpire key 100	// 100ms后过期
	. expireat key 100	// 某个时间戳过期（s）
	. pexpireat ket 100		// 某个时间戳过期（ms）

#### 2.1 判断key是否过期

当我们对一个key设置了过期时间，Redis会将这个key和过期时间存储到过期时间中去，完整流程为

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5/%E8%BF%87%E6%9C%9F%E5%88%A4%E6%96%AD%E6%B5%81%E7%A8%8B.jpg) 

#### 2.2 过期删除策略有哪些

常用的删除策略有以下三种

- 定时删除策略
- 惰性删除策略
- 定期删除策略

**定时删除策略**

做法：在设置key过期时间时，同时创建一个定时事件，在key达到过期时间时，执行该事件删除key

优点：可以保证已经过期的key尽快的删除，内存可以尽快释放。

缺点：这种策略会占用一定的cpu，当内存充足CPU紧张时，将CPU时间用在这种任务上，无疑会对服务器的响应时间和吞吐率照成影响。所以，定时策略对CPU不友好。

**惰性删除策略**

做法：不主动删除过期的key，当有请求访问key时，会对key进行过期检查，如果过期了则删除掉

优点：因为该策略只在访问时，才会检查key，所以只会很少的占用CPU系统资源，因此该策略对CPU时间最友好。

缺点：过期的key没有得到及时删除，会占用系统内存空间。

**定期删除策略**

做法：每隔一段时间随机抽取Redis中的部分key做检查，并删除其中过期的key

优点：限制了删除任务的时长和频率，可以减少部分的CPU资源的占用，也可以释放部分内存

缺点：即达不到定时删除策略的彻底删除，也没有惰性删除策略的占用系统资源少。难以确定删除操作执行的时长和频率。如果执行的太频繁，定期删除策略变得和定时删除策略一样，对CPU不友好；如果执行的太少，那又和惰性删除一样了，过期 key 占用的内存不会及时得到释放。

## 2022.11.02

#### 2.3 设置Redis最大运行内存

- 64位操作系统，maxmemory 设置为0，及不设内存限制，当Redis占用超过最大运行内存时，后面有添加操作，则会OOM。
- 32位操作系统，maxmemory 默认为3G，因为32位操作系统最大运行内存空间位4G，系统本身也需要一些内存来支持运行。

## 2022.11.03

### 三、主从复制实现

#### 3.1 第一次同步

三个阶段：

**第一阶段 建立链接，协商同步**

从服务器执行 replicaof 命令（Redis5.0前是用slaveof命令）

```markdown
# 命令格式
replicaof <服务器A的ip地址> <服务A的Redis端口号>
```

执行完该命令，从服务器会发送**pysnc**命令，表示要进行数据同步

主服务器收到该命令后，响应**FULLRESYNC**命令，该命令表示采用全量复制的方式，也就是把主服务器的所有数据复制到从服务器

**第二阶段 主服务器同步数据到从服务器**

主服务器执行**bgsave**命令生成**RDB文件**，随后将文件发送给从服务器

从服务器收到文件后，清空所有的缓存数据，加载该RDB文件。加载完成后，从服务器回复确认命令

特殊情况：主服务器生成RDB文件期间，因为执行的是bgsave命令，会产生一个子线程来生成**RDB**文件，主线程任然可以执行命令，如执行了写命令，则会造成主从数据不一致。

处理：Redis会在三个阶段将写操作命令写入到**replication buffer**中

第一阶段 主服务生成RDB文件期间

第二阶段 主服务器发送RDB文件到从服务器期间

第三阶段 从服务器加载RDB文件期间

**第三阶段 主服务器发送新的写操作命令到从服务器**

主服务器收到确认命令后，将**replication buffer**记录的写操作命令发送给从服务器，从服务器执行主服务器发送的写操作命令，自此主从服务器数据一致，第一次同步完成。

#### 3.2 命令传播

主服务器与从服务器完成第一次数据同步后，会维持一个TCP连接，后续有新的写操作命令，主服务器会从该连接传播给从服务器，从服务器执行命令保持数据同步。

该连接是一个长连接，目的是避免频繁的进行TCP连接和断开带来的性能开销。

#### 3.3 分摊主服务器压力

从服务器不止一台，每一台服务器如果都与主服务器进行同步，则主服务器则会忙于使用fork()创建子线程，如果主服务器的数据非常大，则fork()函数会阻塞主线程的运行，并且RDB文件传输也会占用主服务器的网络带宽，会对主服务器响应命令造成影响。

服务器也可以执行**replicaof <从服务器ip地址> <从服务器Redis端口>**，这时从服务器就会成为该服务器的主服务器，不仅可以接受它的主服务器的写操作命令，可以承担起同步数据的任务。

#### 3.4 增量复制

情况：网络连接会有延迟，中断等情况

如果从服务器重新恢复连接，从服务器和主服务器又会进行一次全量复制，这样的开销太大，从**Redis2.8之后**，

网络断开又恢复，会采用增量复制的方式，也就是把主服务器在这期间的写操作命令同步给从服务器。

主要有三个步骤：

- 从服务器恢复连接后，发送pysnc命令给主服务器，此时offset参数的值不为-1
- 主服务器收到命令后，发送Continue命令告诉服务器是增量复制的方式同步数据
- 然后主服务器发送期间的写操作命令给从服务器，从服务器加载收到的命令，完成数据同步

repl_backlog_offset:环形缓冲区，用于主从服务器断连后，从中找到差异的数据

replication offset：记录主服务器写的进度和从服务器读的进度



网络断开后，当从服务器重新连上主服务器时，从服务器会通过 psync 命令将自己的复制偏移量slave_repl_offset 发送给主服务器，主服务器根据自己的 master_repl_offset 和 slave_repl_offset 之间的差距，然后来决定对从服务器执行哪种同步操作：

- 如果判断出从服务器要读取的数据还在 repl_backlog_buffer 缓冲区里，那么主服务器将采用**增量同步**的方式；
- 相反，如果判断出从服务器要读取的数据已经不存在 repl_backlog_buffer 缓冲区里，那么主服务器将采用**全量同步**的方式。





